## Error handling 

#### Prosesses

- There two types of processes: <i><b>system process</b></i> and <i><b>normal process</b><i/>
- spawn/* creates a normal process
- a normal process can become a system process by evaluating <code>process_flag(trap_exit, true)</code>

#### Links

- Processes can be linked. If the two processes A and B are linked, and A terminates
  for any reason, and error signal will be sent to B, and the other way round

#### Link sets

- The link set of a process P is the set of processes that are linked to P

#### Monitors

- Monitors are similar to links but are one-directional. If A monitors B
  and if B terminates for any reason, a down message will be sent to A but not the
  other way round

#### Messages and error signals

- Processes collaborate by exchanging messages or error signals. Messages are sent using
  the send (!) primitive. Error are sent automatically when a process terminates or crashes.
  The error signals are sent to the link set of the process that terminated

#### Receipts of an error signal 
##### System process:
- When a system process receives an error signal, the signal is converted into a message of the form {'EXIT', Pid, Why}
- Pid is the process that terminated and Why is reason for terminating. 
- If the terminated process exited without an error, Why will be the atom: normal

##### Normal process:
- When a normal process receives an error signal, it will terminate if the exit reason is not normal
- When it terminates, it will also broadcast an exit signal to its link set

#### Explicit error signals

- a process that evaluates exit(Why) will terminate (if this code is not executed within the scope of a catch or try primitive)
  and will broadcast an exit signal with the reason Why to its link set
- a process can send a fake error signal by evaluating exit(Pid, Why). In this case, Pid will receive
  an exit signal with the reason Why. The process that called exit/2 does not die

#### Untrappable Exits

- When a system process receives a kill signal, it terminates. Kill signals are generated by exit(Pid,kill)
- This signal bypasses the normal error signal processing mechanism and is not converted into a message
- The exit signal should be reserved for rogue processes that refuse to die using any of the other error handling mechanisms

#### The processes that die together

- if multiple processes are linked and no is a system process, when one process dies, the whole link set will die too
- FIREWALL: a process acts as a firewall if it evaluates: <code>process_flag(trap_exit, true)</code>
- if a linked process dies, all process in the link will die too up to the firewall- will not die

#### Monitors 

- monitors are unidirectional
- if A monitors B and B dies, then A will be sent an exit message but not the other way around.
- NOTE: links are bi-directional, if A and B were linked, the death of one process will result in the other one informed
- when a monitored process dies. a down message and not an exit signal is sent to the monitoring process.
- this means that the monitoring process does not have to become a system process in-order to handle errors.

##### Use cases monitors vs links 

- Monitors are used when you want asymmetry error handling. Monitors are typically used by servers to monitor behaviours of clients
- Links are used when you need symmetric error handling 
- 